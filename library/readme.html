<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Design considerations</title>
<style type="text/css">
html {
	color: black;
	background-color: white;
}

h1,h2,h3,h4,h5,h6 {
	color: #0080C0;
}

a:link,a:visited,q {
	color: #0070B0;
}

a:link,a:visited {
	text-decoration: none;
	border-bottom: 1px solid #30A0E0;
}

a:hover,a:active {
	color: black;
	border-bottom: 1px solid black;
}

p {
	width: 48em;
}

ol {
	padding-left: 2em;
}

li {
	width: 46em;
	line-height: 1.4em;
}

pre {
	width: 60em;
	padding: 1em;
	background-color: #000000;
	color: #FFFFFF;
}

li pre {
	width: 46em;
}

blockquote {
	width: 46em;
	margin-left: 2em;
	padding: 1px 0 1px 1em;
	border-left: 4px solid #0080C0;
	background-color: #F0F0F0;
	margin-left: 2em;
}

blockquote p {
	width: 44em;
}

blockquote pre {
	width: 44em;
}

code {
	color: #00A060;
}

.note {
	border: 1px solid #C0C0C0;
	color: #608080;
	background-color: #E0E8E8;
	padding: 1em;
	font-size: 90%;
}
</style>
</head>
<body>
	<h1>Serquant</h1>
	<p>A library designed to help building PHP applications based on
		Zend and Symfony frameworks.</p>

	<h2>Table of contents</h2>
	<ol>
		<li><a href="#frontEnd">Front-end</a></li>
		<li>Back-end layers (these layers should be coupled together as
			little as possible)
			<ol>
				<li><a href="#controller">Controller</a></li>
				<li><a href="#service">Service</a></li>
				<li><a href="#domain">Domain (business logic)</a></li>
				<li><a href="#persistence">Persistence (or Data source)</a>
				</li>
			</ol></li>
	</ol>

	<h2>
		<a name="controller">Controller layer</a>
	</h2>
	<p>The main purpose of the controller (on input) is to transform
		the incoming request to conform with the service layer API
		requirements and inject the result into the view script.</p>
	<p>
		When a controller (Default, Rest, etc.) receives an HTTP request from
		a client (browser or any other client such as a web service), some
		additional data may be held by the URI (with GET and DELETE methods)
		or may reside in the request body (with POST and PUT methods). When
		data reside in the request body, the
		<code>Serquant\Controller\Helper\Params</code>
		action helper decodes them according to their content type. For the
		moment, three content types are implemented: JSON, XML and the default
		<code>enctype</code>
		of forms (
		<code>application/x-www-form-urlencoded</code>
		).
	</p>
	<ol>
		<li>With JSON, either the Zend Framework built-in decoder or the
			PHP native function (json_decode) is used. In both cases, the result
			is the same: a type conversion is done (that is not application-aware
			as we can see with the date).<pre>
$encoded = '{ 
  "null": null, 
  "bool": true, 
  "int0": 0, 
  "int1": 1, 
  "float": 1.56, 
  "string": "hello", 
  "array": [0, 1, 2], 
  "object": {"a":1}, 
  "date": "2010-09-09"
}';
$decoded = json_decode($encoded); // or Zend_Json_Decoder:decode()
var_dump($decoded);

object(stdClass)#1 (9) { 
  ["null"]=> NULL 
  ["bool"]=> bool(true)
  ["int0"]=> int(0)
  ["int1"]=> int(1)
  ["float"]=> float(1.56)
  ["string"]=> string(7) "hello"
  ["array"]=> array(3) { [0]=> int(0) [1]=> int(1) [2]=> int(2) } 
  ["object"]=> object(stdClass)#2 (1) { ["a"]=> int(1) } 
  ["date"]=> string(10) "2010-09-09" 
}</pre>Hence, the result primarily depends on variable types used on client
			side (defined by a dojo.store, for instance).</li>
		<li>With XML, the result is constructed with Zend_Config_Xml
			class. No type conversion is done for scalars. Vectors are always
			converted to arrays. <pre>
$encoded = &lt;&lt;&lt;EOT
&lt;config xmlns:zf="http://framework.zend.com/xml/zend-config-xml/1.0/"&gt;
  &lt;null&gt;null&lt;/null&gt; 
  &lt;bool&gt;true&lt;/bool&gt; 
  &lt;int0&gt;0&lt;/int0&gt; 
  &lt;int1&gt;1&lt;/int1&gt; 
  &lt;float&gt;1.56&lt;/float&gt; 
  &lt;string&gt;hello&lt;/string&gt; 
  &lt;array&gt;
    &lt;item&gt;0&lt;/item&gt;
    &lt;item&gt;1&lt;/item&gt;
    &lt;item&gt;2&lt;/item&gt;
  &lt;/array&gt; 
  &lt;object&gt;
    &lt;a&gt;1&lt;/a&gt;
  &lt;/object&gt; 
  &lt;date&gt;2010-09-09&lt;/date&gt;
&lt;/config&gt;
EOT;
$parsed = new \Zend_Config_Xml($encoded);
$decoded = $parsed->toArray();
var_dump($decoded);

array(
  'null' => string 'null' (length=4)
  'bool' => string 'true' (length=4)
  'int0' => string '0' (length=1)
  'int1' => string '1' (length=1)
  'float' => string '1.56' (length=4)
  'string' => string 'hello' (length=5)
  'array' => array(
    'item' => array(
      0 => string '0' (length=1)
      1 => string '1' (length=1)
      2 => string '2' (length=1)
    )
  )
  'object' => array(
    'a' => string '1' (length=1)
  )
  'date' => string '2010-09-09' (length=10)
)</pre>
		</li>
		<li>With default form <code>enctype</code>, the native PHP
			function <code>parse_str</code> is used, which does no type
			conversion at all.</li>
	</ol>

	<p>Different content types will result in different PHP types. As a
		consequence, converters MUST accomodate this situation and handle
		properly raw string types as well as converted types.</p>


	<h2>
		<a name="service">Service layer</a>
	</h2>
	<p>
		Index: <br /> <a href="#form">Form</a><br /> <a
			href="#conversionValidation">Conversion &amp; validation</a><br />
		&gt;&nbsp;<a href="#conversion">Conversion</a><br /> &gt;&nbsp;<a
			href="#validation">Validation</a><br />
	</p>

	<h3>
		<a name="form">Form</a>
	</h3>
	<ul>
		<li>A form represents a business object.</li>
		<li>A form object shall only take care of presentation and <strong>client-side</strong>
			validation/filtering.</li>
	</ul>

	<p>With basic objects, the names of form elements can match the
		property names of the corresponding entity (the business object). This
		simple design avoids having an additional mapping between form
		elements (the element names used in the HTML form) and property names
		(of the domain). As property names of the entity are unique by design,
		there is no risk to get a collision between two form fields having the
		same id (bear in mind a form represents a business object). No need to
		use any array notation in forms.</p>
	<p>
		Simple entities (having no association) may be represented safely with
		this flat model. Unfortunately, more complex entities (implementing
		associations) will break this model. Let's think of a <em>Customer</em>
		entity having an association with an <em>Address</em> entity. Though
		internally customer details and address will belong to two separate
		entities, it will be displayed to the end user as a single form:
	</p>
	<pre>
&lt;form action="..."&gt;
  &lt;p&gt;
    &lt;input type="hidden" name="id" /&gt;
    &lt;label for="name"&gt;name&lt;/label&gt;
      &lt;input type="text" name="name" /&gt;
    &lt;input type="hidden" name="addressId" /&gt;
    &lt;label for="postalCode"&gt;postal code&lt;/label&gt;
      &lt;input type="text" name="postalCode" /&gt;
    &lt;label for="city"&gt;city&lt;/label&gt;
      &lt;input type="text" name="city" /&gt;
    
    &lt;input type="submit" /&gt;
  &lt;/p&gt;
&lt;/form&gt;</pre>
	<pre>
class Customer {
  private $id;
  private $name;
  private $address;
}

class Address {
  private $id;
  private $postalCode;
  private $city;
}</pre>
	<p>This implies a hierarchical representation of data that is
		incompatible with the flat model. The server will serialize outgoing
		data this way:</p>
	<pre>
{
  "id": "1240",
  "name": "Dupont",
  "address": {
    "id": "9571",
    "postalCode": "77400",
    "city": "Lagny-sur-Marne"
  }
}</pre>
	<p>or (when the associated entity has not been retrieved yet):</p>
	<pre>
{
  "id": "1240",
  "name": "Dupont",
  "address": {
    "$ref": "9571"
  }
}</pre>
	<p>This is achieved by the serializer.</p>
	<p>
		Unfortunately, the same data structure will be presented to the
		service layer for validation (see <a href="frontEndDesign">front-end
			design</a>). With a classical Zend_Form validation, the form (holding the
		presentation) and the entity have different structures. It doesn't
		match. We therefore need to <strong>de-couple form
			presentation from validation</strong>. This is achieved by removing every
		server-side filtering/validating code from the Zend_Form object and
		putting it <em>somewhere else</em>. But where?
	</p>

	<p>
		Could it be a
		<code>Zend_Filter_Input</code>
		object? The previous example with Customer/Address shows an object
		referencing another object. If we don't want to repeat our code,
		address validation should not be done within customer validation (or
		there is a chance that the same code will be duplicated for a supplier
		address or another address in the application). But
		<code>Zend_Filter_Input</code>
		does not process its elements recursively. As though, it is not a good
		candidate for the validation.
	</p>

	<h3>
		<a name="conversionValidation">Conversion &amp; validation</a>
	</h3>
	<p>
		To de-couple form presentation from validation, we decided to use
		Symfony's <a href="http://symfony.com/doc/2.0/book/validation.html">Validator</a>
		component instead of Zend Framework's one. Symfony describes it as a
		PHP port of the Hibernate implementation of <a
			href="http://jcp.org/en/jsr/detail?id=303">JSR-303 Bean
			Validation specification</a>. The paradigm is very different from Zend
		Framework's filtering and validating process. Here is the new
		validation process:
	</p>
	<ol>
		<li>type conversion is done first</li>
		<li>then the entity is populated</li>
		<li>finally, the validator validates the populated entity.</li>
	</ol>
	<p>Violations may happen at conversion stage (1) or at validation
		stage (3).</p>
	<p>
		Validation constraints can be specified via a number of different
		formats: YAML, XML, annotations, or PHP. I prefer the annotations for
		beeing in the same place as ORM mapping. See the list of <a
			href="http://symfony.com/doc/2.0/book/validation.html#supported-constraints">supported
			constraints</a>.
	</p>

	<h4>
		<a name="conversion">Conversion</a>
	</h4>

	<ul>
		<li>The process of converting incoming data into an entity of the
			domain is done by<br /> <code>Serquant\Converter\Serializer#deserialize</code>
		</li>
		<li>Only entity properties marked for conversion are converted</li>
		<li>Conversion may only be defined with annotations for the
			moment</li>
		<li>The target type is determined by the <em>type</em> attribute
			of the <em>Property</em> annotation.</li>
	</ul>
	<p>For instance:</p>
	<pre>
use Serquant\Converter\Mapping as Converter;
    
class User
{
    /**
     * @Converter\Property(type="integer")
     */
    private $id;

    /** 
     * @Converter\Property(type="string")
     */
    private $name;
    
    ...
}</pre>

	<p>When populating an entity from input data, any setter defined in
		the entity will be used. For instance:</p>
	<pre>
use Serquant\Converter\Mapping as Converter;
    
class User
{
    /**
     * @Converter\Property(type="integer")
     */
    private $id;

    /** 
     * @Converter\Property(type="string")
     */
    private $name;

    /**
     * Sets user name
     *
     * @param string $name User name
     * @return void
     */
    public function setName($name) // Will be used by Serializer#deserialize()
    {
        $this-&gt;name = $name;
    }
    
    ...
}</pre>

	<h5>
		<a name="identifierPrefix">Identifier prefix</a>
	</h5>
	<p>When data is serialized to JSON before beeing sent to the
		client, no type information is given. For instance, in the following
		code:</p>
	<pre>
{
  "id": "1240",
  "name": "Dupont",
  "address": {
    "id": "9571",
    "postalCode": "77400",
    "city": "Lagny-sur-Marne"
  }
}</pre>
	<p>we don't know which object class id, name and address properties
		belong to or the one id, postalCode and city belong to. Thus, the
		client receiving this data is unable to handle it properly (ie
		populate the dojo store in our situation).</p>

	<p>If we serialize the same data with an identifier prefix, the
		JSON becomes:</p>
	<pre>
{
  "id": "/person/1240",
  "name": "Dupont",
  "address": {
    "id": "/address/9571",
    "postalCode": "77400",
    "city": "Lagny-sur-Marne"
  }
}</pre>

	<p>permitting the client to distinguish object classes from each
		others.</p>
	<p>
		Therefore, an identifier prefix feature exists on the Serializer which
		adds the prefix on serialization and removes it on deserialization. To
		be set, add a <em>@Converter\Entity</em> annotation to the entity and
		specify which property is the identifier with the <em>@Converter\Id</em>
		annotation:
	</p>

	<pre>
use Serquant\Converter\Mapping as Converter;
 
/**
 * @Converter\Entity(prefix="/rest/user/")
 */   
class User
{
    /**
     * @Converter\Property(type="integer")
     * @Converter\Id
     */
    private $id;
    ...
}</pre>

	<p>
		<small> La conversion opposée est réalisée par le contrôleur,
			via un script de vue, car c'est lui qui sait la forme attendue (JSON,
			XML, plain text, etc.). <em>Il semble curieux que le transtypage
				ne soit pas réalisé dans les deux sens par le même layer. Peut-être
				serait-il judicieux que ce soit le contrôleur qui réalise le
				transtypage en entrée.</em> </small>
	</p>

	<h5>
		<a name="multivaluedProperties">Multivalue property notes</a>
	</h5>

	<p>For multivalued properties representing associations, adding a
		value to the property may be done with the following code:</p>
	<pre>
class Car {
    private $id;
    private $brand;
    // Accessors...
}

class Person {
    private $id;
    private $name;
    private $cars;
    // Accessors...
}

$car = new Car();
$person-&gt;getCars()-&gt;add($car);
</pre>
	<p>
		This is the simplest way to do it.<br />
		<code>Serquant\Converter\Serializer#deserialize</code>
		uses this
		<code>add()</code>
		method defined by the
		<code>Collection</code>
		interface.<br />It is <em>sufficient for unidirectional
			association</em> but with bidirectional association, we also need to
		update the other side:
	</p>
	<pre>
class Car {
    private $id;
    private $brand;
    private $owner; // now bidirectional
    // Accessors...
}

class Person {
    private $id;
    private $name;
    private $cars;
    // Accessors...
}

$car = new Car();
$person-&gt;getCars()-&gt;add($car);
$car-&gt;setOwner($person);
</pre>

	<p>
		As stated by <a
			href="http://www.doctrine-project.org/docs/orm/2.0/en/reference/working-with-associations.html#association-management-methods">Doctrine
			documentation</a>:
	</p>
	<blockquote>
		<p>
			It is generally a good idea to encapsulate proper association
			management inside the entity classes. <br />This makes it easier to
			use the class correctly and can encapsulate details about how the
			association is maintained.
		</p>
	</blockquote>
	<p>The code becomes;</p>
	<pre>
class Car {
    private $id;
    private $brand;
    private $owner; // now bidirectional
    // Accessors...
}

class Person {
    private $id;
    private $name;
    private $cars;
    // Accessors...
    public function addCar(Car $car) {
        $this-&gt;cars-&gt;add($car);
        $car-&gt;setOwner($this);
    }
}

$car = new Car();
$person-&gt;addCar($car);
</pre>

	<p>
		Unfortunately, Serquant can't infer the <em>addCar</em> method name
		from the <em>$cars</em> property. The property name is plural but the
		function name is singular (as it describes the action of adding <em>one</em>
		item). To be able to use this method in
		<code>Serquant\Converter\Serializer#deserialize</code>
		, we should find the singular form of the property. But many words
		have defective plural and some others ends in <em>s</em> even when
		singular in meaning. <strong>An issue will be opened to
			fulfill this requirement suggesting to add a <em>setter</em>
			attribute to the <em>Property</em> association.</strong>
	</p>

	<h4>
		<a name="validation">Validation</a>
	</h4>

	<ul>
		<li>The process of validating an entity is done by the <code>Symfony\Component\Validator\Validator</code>
			service.</li>
		<li>Only entity properties wearing constraints metadata are
			validated.</li>
		<li>Constraints may be defined with annotations, YAML or XML
			configuration files.</li>
		<li>The supported constraints may be found <a
			href="http://symfony.com/doc/2.0/book/validation.html#supported-constraints">
				here</a>.</li>
	</ul>

	<pre>
use Symfony\Component\Validator\Constraints as Assert;

class User
{
    private $id;

    /** 
     * @Assert\MaxLength(50) 
     */
    private $name;

    /**
     * @Assert\Email(
     *     message = "The email '{{ value }}' is not a valid email.",
     *     checkMX = true
     * )
     */
    private $email;

    ...    
}</pre>
	<h2>
		<a name="domain">Domain</a>
	</h2>
	<h4>POJO</h4>
	<p>
		Le domaine est constitué d'objets métier, qui doivent rester aussi
		simples que possible (principe de simplicité nommé par Martin Fowler <a
			href="http://www.martinfowler.com/bliki/POJO.html">POJO</a>).<br />
		Domain entities must declare their properties either protected or
		private to conform with EJB 3 specification.<br /> Les magic
		getters/setters sont à proscrire, comme toutes les fonctions magiques
		d'une manière générale, du fait de la difficulté de compréhension du
		code qu'elles introduisent et de la dégradation de performance
		qu'elles provoquent.
	</p>
	<p>
		Les dates sont représentées par des classes
		<code>\DateTime</code>
	</p>

	<h4>No infrastructure code in domain for persisting</h4>
	<p>
		Ces objets ne doivent comporter que des propriétés et méthodes liées
		au métier et pas d'élément d'infrastructure.<br /> L'infrastructure
		étant rejetée à l'extérieur, il est nécessaire d'ajouter à ces objets
		des métadonnées qui en définissent la persistence. La correspondance
		entre le modèle objet du domaine et le modèle relationnel des bases de
		données a été formalisée par la communauté Java dans la spécification
		<a href="http://www.jcp.org/en/jsr/detail?id=317">Java Persistence
			API</a> (actuellement Version 2.0) qui est la partie persistence de
		données de la norme EJB3 (JSR 220). Elle a donné lieu à une
		implémentation de référence : Hibernate. Les frameworks qui réalisent
		la persistence sont appelés ORM. Dans le monde PHP, les principaux ORM
		sont Doctrine et Propel.<br /> Pour implémenter la couche de
		persistence, je choisis d'adopter ces métadonnées (pas forcément sous
		la forme d'annotations d'ailleurs). Et pour éviter de réécrire le code
		qui gère ces métadonnées, j'emploie celui de Doctrine.
	</p>
	<p>
		L'implémentation des métadonnées réalisée par Doctrine ne pose pas de
		problème pour le mapping (la fonction étant identique), mais en pose
		un avec la notion de <em>table data gateway</em> qui est nécessaire
		pour le persister Zend. Dans ce cas, j'utilise l'attribut
		<code>repositoryClass</code>
		(
		<code>@Entity(repositoryClass="...")</code>
		) pour signifier la <em>table data gateway</em> à utiliser. Mais cette
		utilisation abusive masque une différence substantielle entre la
		notion de <em>entity repository</em> chez Doctrine et celle de <em>table
			data gateway</em> chez Zend.
	</p>
	<pre>
&#47;&#42;&#42;
 &#42; Customer entity
 &#42;
 &#42; &#64;Entity(repositoryClass="MyDbTable")
 &#42;&#47;
class Customer
{
    &#47;&#42;&#42;
     &#42; &#64;Id
     &#42; &#64;Column(name="id", type="integer")
     &#42; &#64;GeneratedValue(strategy="AUTO")
     &#42;&#47;
    protected $id;

    &#47;&#42;&#42; &#64;Column(name="action", type="string", length=40, unique=true) &#42;&#47;
    protected $action;
    // ...
}
</pre>
	<p>
		The entity manager uses
		<code>ClassMetadataFactory#getMetadataFor()</code>
		function for all of the operations related to metadata. (We may change
		the factory from Doctrine configuration.) Once the factory is
		instantiated, two of its properties are successively set: the entity
		manager and a cache driver. The ClassMetadataFactory is therefore
		tightly coupled with the entity manager. But, let's examine the class
		in more depth. First, the <strong>cache driver</strong> is not
		required but only recommended. Second, inside
		<code>ClassMetadataFactory#initialize()</code>
		the entity manager is used:
	</p>
	<ul>
		<li>To retrieve the <strong>metadata driver</strong> from the
			configuration:<br /> <code>$this-&gt;em-&gt;getConfiguration()-&gt;getMetadataDriverImpl()</code><br />
			<em>There is no setter to do it otherwise.</em></li>
		<li>To retrieve the <strong>database platform</strong> from the
			database connection:<br /> <code>$this-&gt;em-&gt;getConnection()-&gt;getDatabasePlatform()</code><br />The
			database platform is only needed to complete the ID generator
			mapping.<br /> <em>There is no setter to do it otherwise.</em></li>
		<li>To get the <strong>event manager</strong>:<br /> <code>$this-&gt;em-&gt;getEventManager()</code><br />The
			event manager is used to trigger a listener if one is registered for
			metadata loading.<br /> <em>There is no setter to do it
				otherwise.</em><br />At first, I thought it would be impossible to
			handle this event as it would conduct to reimplement an event manager
			independent from Doctrine. But the event manager is <em>already</em>
			independent from Doctrine, beeing in its <code>Common</code>
			namespace.</li>
		<li>Later, the entity manager is used to get the <strong>entity
				namespace</strong> from Doctrine configuration (if namespace notation is
			used):<br /> <code>$this-&gt;em-&gt;getConfiguration()-&gt;getEntityNamespace($namespaceAlias)</code>
		</li>
		<li>Finally, as an argument to the <code>LoadClassMetadataEventArgs#__construct()</code>
			(again for the event manager):<br /> <code>new
				\Doctrine\ORM\Event\LoadClassMetadataEventArgs($class, $this-&gt;em)</code>
		</li>
	</ul>
	<p>If we were about to overwrite ClassMetadataFactory, some
		configuration options would be required: the metadata driver, the
		metadata cache, the namespace and the database platform.</p>
	<p>
		<small> Le fait d'utiliser certaines classes de Doctrine sans
			passer par son <em>entity manager</em> n'est pas évident. Tous les
			composants sont intimement liés dans Doctrine et tenter de les
			séparer soulève des questions (utilisation des métadonnées sans
			mécanisme de cache, récupération des options de configuration de
			Doctrine ou de Zend pour déterminer la plateforme SGBD). D'un autre
			côté, il semble aberrant d'instancier l'<em>entity manager</em> de
			Doctrine simplement pour lire les métadonnées des modèles Zend et
			réaliser le transtypage.<br /> Pour l'instant, je décide de ne pas
			utiliser l'<em>entity manager</em> et d'obtenir la plateforme par une
			table de correspondance entre l'adaptateur défini pour Zend et les
			plateformes définies par Doctrine.</small>
	</p>

	<h4>No infrastructure code in domain for rendering</h4>

	<p>
		While doing some experiments on PHP 5.4 Traits, Benjamin Eberlei
		prototyped <a href="https://gist.github.com/1034079">a few classes</a>
		to serialize a Doctrine entity into several formats (JSON, XML). After
		having analyzed those classes, I concluded two external objects would
		be necessary to serialize an entity: a class metadata factory and an
		identity map of entities (with Doctrine, this identity map is embedded
		in UnitOfWork). The metadata are necessary to get persistent fields
		and the identity map is used to retrieve the identifier of
		single-valued associations.
	</p>

	<h2>
		<a name="persistence">Persistence Layer or Data Mapper</a>
	</h2>

	<p>
		The role of a Persistence Layer (aka <a
			href="http://martinfowler.com/eaaCatalog/dataMapper.html">Data
			Mapper</a>) is to map the objects of the <a
			href="http://martinfowler.com/eaaCatalog/domainModel.html">Domain
			Model</a> to the structure used by the storage system. For instance, a
		date is an instance of the PHP
		<code>DateTime</code>
		class in the Domain Model and must be converted to a string with a
		specific representation (
		<code>'Y-m-d H:i:s'</code>
		) to be stored in a MySQL database.
	</p>
	<p>
		The mapper usually does the mapping through <a
			href="http://martinfowler.com/eaaCatalog/metadataMapping.html">Metadata
			Mapping</a>. However, in his PoEAA book, Fowler explains that <q>The
			simplest, and often best, way to do this is with explicit code, which
			requires a mapper class for each domain object</q>. For this reason, it
		is always possible to use explicit code by implementing the
		<code>Persistence</code>
		interface of the
		<code>Persistence</code>
		package for a particular entity, and pass that specific persister to
		the
		<code>Crud</code>
		constructor:
	</p>
	<pre>
class CustomPersister implements Persistence 
{
    // ...
}

$customPersister = new CustomPersister();
$service = new Crud('User', $customPersister);
</pre>
	<p>
		Two kinds of persisters may be used in the application. The first one
		is
		<code>Serquant\Persistence\Doctrine</code>
		(a thin adapter around Doctrine). Doctrine is the most advanced ORM in
		PHP (based on Hibernate). The second one is
		<code>Serquant\Persistence\Zend</code>
		(a pseudo-ORM using Zend_Db_Table for data access).
	</p>

	<h3>
		<a name="persistenceZend">Zend persister</a>
	</h3>

	<p>
		This persister has the following <em>limitations</em>:
	</p>
	<ul>
		<li>it doesn't manage one-to-one bidirectional associations</li>
	</ul>
	<p>
		To avoid reinventing the wheel, we use Doctrine implementation of the
		Metadata Mapping. When the annotations are used, one can find this
		kind of comments in entities:<br />
		<code>/** @Column(name="title", type="string", length=100,
			nullable=true) */</code>
	</p>
	<p>By nature, the persistence layer is a Data Mapper as the domain
		model is an object model and the storage is a different model. It may
		be an ORM (Object/Relational Mapper) when the storage is a RDBMS. It
		may also be an ODM (Object/Document Mapper) when the storage is a
		document-oriented database. We can even imagine an OSM (Object/Service
		Mapper) in which data would be managed by an external service.</p>
	<p>
		To load an entity from the database, the client calls a <em>retrieve</em>
		method of the Data Mapper. The Data Mapper uses an <a
			href="http://martinfowler.com/eaaCatalog/identityMap.html">Identity
			Map</a> to check if the entity is already loaded. But, as stated by
		Fowler, <q>Since objects are very interconnected, you usually have
			to stop pulling the data back at some point. Otherwise, you're likely
			to pull back the entire database with a request.</q> To deal with this,
		mapping layers use <a
			href="http://martinfowler.com/eaaCatalog/lazyLoad.html">Lazy Load</a>.
	</p>
	<p>Doctrine uses many of the patterns described by Martin Fowler.</p>

	<h3>
		<a name="lifecycleEvents">Persistence lifecycle events</a>
	</h3>

	<p>Doctrine has its own mechanism to handle lifecycle events. Here
		we only describe lifecycle events in the context of the Zend
		persister.</p>

	<p>
		Zend persister defines 6 lifecycle events that are fully described in
		the class containing the following constants (
		<code>Serquant\Event\LifecycleEvent</code>
		):
	</p>
	<ol>
		<li>PRE_PERSIST (function name: 'prePersist')</li>
		<li>POST_PERSIST (function name: 'postPersist')</li>
		<li>PRE_UPDATE (function name: 'preUpdate')</li>
		<li>POST_UPDATE (function name: 'postUpdate')</li>
		<li>PRE_REMOVE (function name: 'preRemove')</li>
		<li>POST_REMOVE (function name: 'postRemove')</li>
	</ol>
	<p>
		Events are managed by an event manager. To not reinvent the wheel, we
		chose an existing one from the Doctrine Common project (
		<code>Doctrine\Common\EventManager</code>
		). The first thing to do is to obtain an event manager instance and
		then to add listeners to this instance. This may be done in a
		traditional way:
	</p>

	<pre>
use Doctrine\Common\EventManager;
use Serquant\Event\LifecycleEvent;
use Serquant\Event\LifecycleEventArgs;

class MyListener
{
    public function __construct($evm)
    {
        $evm-&gt;addEventListener(LifecycleEvent::POST_UPDATE, $this);
    }

    public function postUpdate(LifecycleEventArgs $args)
    {
        // do something
    }
}

$eventManager = new EventManager();
$listener = new MyListener($eventManager);
</pre>

	<p>or it may be done through the service configuration file:</p>
	<pre>
event_config:
    listeners:
        - MyListener

event_manager:
    class: Doctrine\Common\EventManager
    factory_class: Serquant\DependencyInjection\Factory\EventManagerFactory
    factory_method: get
    arguments: [%event_config%]
</pre>

	<p>
		To implement a lifecycle event listener, it is mandatory to respect
		pre-defined method names (to be found in
		<code>Serquant\Event\LifecycleEvent</code>
		) and argument type of these methods. All but one of these methods
		receive an
		<code>Serquant\Event\LifecycleEventArgs</code>
		argument. The only exception is
		<code>preUpdate</code>
		which receives a
		<code>Serquant\Event\PreUpdateLifecycleEventArgs</code>
		argument. Refer to these class API to get full documentation. A basic
		lifecycle event listener implementation would be: 
	</p>
    <pre>
use Doctrine\Common\EventManager;
use Serquant\Event\LifecycleEvent;
use Serquant\Event\LifecycleEventArgs;

class MyListener
{
    public function __construct($evm)
    {
        $evm-&gt;addEventListener(LifecycleEvent::POST_UPDATE, $this);
    }

    public function postUpdate(LifecycleEventArgs $args)
    {
        $entity = $args-&gt;getEntity();
        // Anything to do with me?
        if ($entity instanceof \My\Domain\Entity) {
            // do whatever you want with the entity
        }
    }
}
</pre>

	<h2>
		<a name="frontEnd">Front-end design</a>
	</h2>

	<h4>Implementing associations in stores</h4>
	<p>On server-side, we implement associations between entities
		through entity references. Each entity of the domain is stored in a
		separate place (a database table for instance).</p>

	<p>By joining entities together we get an object graph that can be
		serialized and returned to the client. We may also choose to execute a
		simple query without any join and return only the identifier of the
		referenced objects. Then, on client-side, we could have one store for
		the whole object graph or choose to create multiple stores, each of
		which handlind an entity of the graph.</p>

	<p>
		On client-side, according to a post about <a
			href="http://www.sitepen.com/blog/2008/11/21/effective-use-of-jsonreststore-referencing-lazy-loading-and-more/">Effective
			use of JsonRestStore: Referencing, Lazy Loading, and more</a>, references
		<q>allow us to link to objects within a different namespace, which
			can be associated with a different store</q>. Another post on <a
			href="http://www.sitepen.com/blog/2008/06/17/json-referencing-in-dojo/">JSON
			Referencing in Dojo</a> gives a good example of it:
	</p>
	<blockquote>
		<p>
			Suppose, we load a purchase order object from
			<code>http://mysite.com/PO/1</code>
			:
		</p>
		<pre>
{"id":"1",
 "amount":5.99,
 "purchasedBy":{"$ref":"/Person/1"}
}</pre>
		<p>
			Now we can use relative URLs to determine that the
			<code>purchasedBy</code>
			property is referring to the object from
			<code>http://mysite.com/Person/1</code>
			.
		</p>
	</blockquote>

	<p>
		The identifier prefix was introduced in order to solve a referencing
		issue (see <a href="#identifierPrefix">Identifier prefix</a>). This
		issue occurs when using
		<code>dojox.data.JsonRestStore</code>
		. If we replace that store with the corresponding one of the new dojo
		store API, the problem disappears. Why? Because
		<code>dojo.store.JsonRest</code>
		is much more simple than the former one and does not implement
		referencing (as explained in <a
			href="http://bugs.dojotoolkit.org/ticket/13294">ticket #13294</a>).
	</p>

	<div class="note">
		<h3>Analyse comparative des fonctionnements de Doctrine et Zend</h3>
		<h4>create</h4>
		<p>Dans un create(), c'est la fonction Crud#populate() du service
			layer qui alimente l'entité. Ensuite, chez Doctrine, l'entité créée
			est passée à la fonction persist() de l'EntityManager. La suite se
			déroule ainsi :</p>

		<ol>
			<li><code>EntityManager#persist($entity)</code>
				<ul>
					<li>la fonction appelle <code>UnitOfWork#persist($entity)</code>
						qui renvoie à <code>UnitOfWork#doPersist($entity, $visited)</code>
					</li>
					<li>quand l'état est STATE_NEW, la fonction appelle <code>persistNew($class,
							$entity)</code></li>
					<li>la fonction invoque les événements liés au cycle de vie</li>
					<li>la fonction génère, le cas échéant (assignation d'un
						identifiant avant l'insertion), un identifiant et l'enregistre
						dans les <em>entityIdentifiers</em></li>
					<li>puis elle appelle <code>scheduleForInsert($entity)</code>
					</li>
					<li>If the entity already has an identifier, it will be added
						to the <em>identity map</em>.</li>
				</ul>
			</li>
			<li>Au moment du <code>EntityManager#flush()</code>, <code>UnitOfWork#commit()</code>
				est appelée
				<ul>
					<li>Dans le cas d'une insertion, la fonction exécute <code>UnitOfWork#executeInserts($class)</code>
					</li>
					<li>La fonction invoque à son tour <code>Persister#executeInserts()</code>
						qui réalise, grosso modo, les opérations suivantes :
						<ul>
							<li><code>$stmt =
									$this->_conn->prepare($this->_getInsertSQL());</code>
							</li>
							<li><code>$insertData =
									$this->_prepareInsertData($entity);</code></li>
							<li><code>$stmt->bindValue($paramIndex++, $value,
									$this->_columnTypes[$column])</code></li>
							<li><code>$stmt->execute();</code></li>
						</ul></li>
					<li>Les identifiants retournés après insertion sont utilisés
						pour mettre à jour l'entité et les <em>entityIdentifiers</em>
					</li>
				</ul>
			</li>
		</ol>

		<p>Côté Zend, les choses sont différentes :</p>
		<ol>
			<li><code>Zend_Db_Table_Row_Abstract#setFromArray($data)</code>
				reçoit un tableau associatif qui est parcouru et la fonction <code>Zend_Db_Table_Row_Abstract#__set($columnName,
					$value)</code> est appelée pour chaque élément de ce tableau.</li>
			<li>Dans la méthode <code>Zend_Db_Table_Row_Abstract#__set($columnName,
					$value)</code> :
				<ol>
					<li>Le nom de la colonne est potentiellement infléchi (si la
						méthode <code>Zend_Db_Table_Row_Abstract#_transformColumn()</code>
						est surcharghée)</li>
					<li>Puis la valeur transmise est assignée à la colonne <strong>sans
							transtypage</strong></li>
					<li>Enfin, un indicateur est positionné pour signaler que la
						valeur de la colonne a été modifiée</li>
				</ol></li>
		</ol>

		<h4>retrieve</h4>
		<p>Dans le cas de Doctrine:</p>
		<ul>
			<li>le repository invoque la méthode <code>Persister#load()</code>
				( <code>BasicEntityPersister</code> par exemple).</li>
			<li>Cette fonction appelle à son tour <code>Persister#_createEntity($result,
					$entity, $hints)</code> après avoir exécuté la requête SQL.</li>
			<li><code>Persister#_createEntity()</code> commence par exécuter
				<code>Persister#_processSQLResult($result)</code> qui réalise le
				transtypage</li>
			<li>Finalement, <code>Persister#_createEntity()</code> invoque <code>UnitOfWork#createEntity($entityName,
					$data, $hints)</code> .</li>
			<li>C'est <code>UnitOfWork#createEntity()</code> qui va d'abord
				créer une nouvelle instance puis, grâce aux métadonnées, définir les
				propriétés de l'entity avec les valeurs obtenues via la méthode <code>ReflectionProperty#setValue()</code>.</li>
		</ul>
		<p>Cela signifie que ce ne sont pas les setters de l'entité qui
			sont utilisés et qu'aucun transtypage ne peut être réalisé par eux.</p>

		<h4>update</h4>
		<p>
			Dans le cas d'un update, le service commence par obtenir l'entité
			depuis la base de données (si ce n'est pas déjà fait) puis modifie
			cette entité. La classe
			<code>Zend_Db_Table</code>
			permet de faire une mise à jour directe, sans avoir préalablement lu
			l'entité dans la base de données (
			<code>$table#update($data, $where)</code>
			). Cependant, cette méthode ne permet pas de connaître l'état
			antérieur de cette entité et donc pas de réaliser un traitement
			applicatif si une propriété change par exemple (pas de gestion
			d'événement). Pour cette raison, je choisis d'utiliser la méthode
			<code>Zend_Db_Table_Row#save()</code>
			.
		</p>

		<p>
			Logique de Zend_Db_Table_Row#_doUpdate() invoquée par
			<code>Zend_Db_Table_Row#save()</code>
			:
		</p>
		<ul>
			<li>construit la clause where qui identifie la ligne visée</li>
			<li>invoque une méthode qui est un point d'extension pre-update</li>
			<li>détermine les colonnes de données qui ont changé</li>
			<li>détermine les colonnes de la clé qui ont changé</li>
			<li>si la clé a changé, effectue des updates en cascade sur les
				tables dépendantes</li>
			<li>si les données ont changé, réalise la modification en
				appelant <code>Zend_Db_Table#update()</code></li>
			<li>invoque une méthode qui est un point d'extension post-update</li>
			<li>renvoie la clé</li>
		</ul>

		<p>
			J'envisage un instant de réaliser les mêmes opérations que
			<code>Zend_Db_Table_Row#_doUpdate()</code>
			dans
			<code>Serquant\Persistence\Zend#update()</code>
			, mais cela suppose de conserver l'état antérieur de l'entité, ce qui
			ne fait que déplacer le problème.
		</p>

		<p>
			Comment Doctrine conserve-t-il les entités en mémoire ? La classe
			<code>UnitOfWork</code>
			possède une identity map. Les entités y sont enregistrées sous une
			référence constituée de la classe de l'entité et des composantes de
			sa clé (
			<code>$this->identityMap[$class->rootEntityName][$idHash]</code>
			). <em>rootEntityName</em> est le nom de la classe racine dont
			l'entité hérite. <em>idHash</em> est une chaîne composée de la clé ou
			de la clé étrangère (si l'entité définit une association).
		</p>

		<h4>principe des metadata chez Doctrine</h4>
		<ol>
			<li>Tout commence par l'instanciation d'une factory : <code>new
					$metadataFactoryClassName;</code>
			</li>
			<li>Puis, les métadonnées sont obtenues par <code>ClassMetadataFactory#getMetadataFor(ltrim($entityName,
					'\\'))</code><br />qui appelle <code>ClassMetadataFactory#loadMetadata($className)</code>.<br />
				Cette dernière réalise les opérations suivantes :
				<ol>
					<li>Un tableau de la hiérarchie des classes est constitué (le
						premier élément est la classe racine). Pour chaque élément :
						<ol>
							<li><code>$class =
									ClassMetadataFactory#newClassMetadataInstance($className)</code>
								(cette méthode exécute seulement <code>new
									ClassMetadata($className)</code>)</li>
							<li>Si la classe a un ascendant, on y ajoute les métadonnées
								du parent.</li>
							<li>La méthode <code>Driver#loadMetadataForClass($className,
									$class)</code> est appelée.
								<ul>
									<li>Le driver est ici de type <code>AnnotationDriver</code>
									</li>
									<li>Le driver est obtenu par cette méthode de <code>Doctrine\ORM\Configuration</code>
										: <pre>
    public function newDefaultAnnotationDriver($paths = array())
    {
        $reader = new \Doctrine\Common\Annotations\AnnotationReader();
        $reader-&gt;setDefaultAnnotationNamespace('Doctrine\ORM\Mapping\\');
        
        return new \Doctrine\ORM\Mapping\Driver\AnnotationDriver($reader, (array)$paths);
    }								</pre> <em><code>$path</code> est le chemin où se trouvent
											les entités</em>
									</li>
								</ul></li>
						</ol>
					</li>
				</ol></li>
		</ol>
	</div>

	<h2>
		<a name="developpersGuide">Developper's guide</a>
	</h2>
	<ol>
		<li>Write an entity class.</li>
		<li>Write a form for the new entity.<br />To get a nice
			presentation, this form may extend <code>Technema_Dojo_Form</code>.</li>
		<li>Write a service to manage the new entity.<br />If a standard
			service is sufficient, only add an entry to the <em>service
				configuration file</em>: <pre>
$container-&gt;setDefinition('service_country', new Definition(
&nbsp;&nbsp;'\Serquant\Service\Crud',
&nbsp;&nbsp;array(
&nbsp;&nbsp;&nbsp;&nbsp;'\Domain\Entity\Country', 
&nbsp;&nbsp;&nbsp;&nbsp;new Reference('persistence_doctrine')
&nbsp;&nbsp;)
));
</pre>
		</li>
		<li>Write a default controller to prepare the GUI.<br /> This
			controller must extend <code>Zend_Controller_Action</code>.<br />
			Alternatively, it may extend <code>Serquant\Controller\Action</code>
			if the service layer instance is needed. In this case, it must define
			a protected <var>$serviceName</var> property matching the service
			name defined in the <em>service configuration file</em>.<br />A
			public <code>indexAction()</code> method must be implemented to
			render a grid along with the form written earlier. You may define a
			Grid object that is assigned to a <var>$this-&gt;view-&gt;grid</var>
			property.</li>
		<li>Write a simple view script for the default controller that
			will echo <var>$this-&gt;grid</var>.</li>
		<li>Write a REST controller to manage entity data.<br />This
			controller must extend <code>Serquant\Controller\Rest</code>.<br />It
			must define a protected <var>$serviceName</var> property matching the
			service name previously defined in the <em>service configuration
				file</em>.</li>
	</ol>
</body>
</html>